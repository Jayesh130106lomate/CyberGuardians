"""
vulnerability_intelligence.py - CVE database integration for vulnerability intelligence
"""
import requests
import json
import time
from datetime import datetime, timedelta
from cachetools import TTLCache
import re

class VulnerabilityIntelligence:
    """Handles CVE database queries and vulnerability intelligence"""

    def __init__(self):
        # NIST NVD API base URL
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        # Cache for 1 hour to avoid rate limits
        self.cache = TTLCache(maxsize=100, ttl=3600)
        # Rate limiting: max 50 requests per 30 seconds
        self.request_times = []
        self.rate_limit = 50
        self.rate_window = 30

    def _check_rate_limit(self):
        """Check if we're within rate limits"""
        now = time.time()
        # Remove old requests outside the window
        self.request_times = [t for t in self.request_times if now - t < self.rate_window]

        if len(self.request_times) >= self.rate_limit:
            # Wait until we can make another request
            sleep_time = self.rate_window - (now - self.request_times[0])
            if sleep_time > 0:
                time.sleep(sleep_time)
                self.request_times = [t for t in self.request_times if time.time() - t < self.rate_window]

        self.request_times.append(now)

    def _make_request(self, params):
        """Make a request to NVD API with rate limiting and error handling"""
        self._check_rate_limit()

        try:
            response = requests.get(self.base_url, params=params, timeout=30)
            response.raise_for_status()

            # Parse JSON response
            data = response.json()
            return data

        except requests.exceptions.RequestException as e:
            print(f"Error fetching CVE data: {e}")
            return None
        except json.JSONDecodeError as e:
            print(f"Error parsing CVE response: {e}")
            return None

    def search_cves_by_keyword(self, keyword, limit=20):
        """Search for CVEs by keyword"""
        cache_key = f"keyword_{keyword}_{limit}"

        if cache_key in self.cache:
            return self.cache[cache_key]

        params = {
            'keywordSearch': keyword,
            'resultsPerPage': limit,
            'startIndex': 0
        }

        data = self._make_request(params)
        if not data:
            return []

        cves = self._parse_cve_response(data)
        self.cache[cache_key] = cves
        return cves

    def search_cves_by_cpe(self, cpe_name, limit=20):
        """Search for CVEs by CPE (Common Platform Enumeration)"""
        cache_key = f"cpe_{cpe_name}_{limit}"

        if cache_key in self.cache:
            return self.cache[cache_key]

        params = {
            'cpeName': cpe_name,
            'resultsPerPage': limit,
            'startIndex': 0
        }

        data = self._make_request(params)
        if not data:
            return []

        cves = self._parse_cve_response(data)
        self.cache[cache_key] = cves
        return cves

    def get_cve_details(self, cve_id):
        """Get detailed information for a specific CVE"""
        cache_key = f"cve_{cve_id}"

        if cache_key in self.cache:
            return self.cache[cache_key]

        params = {
            'cveId': cve_id
        }

        data = self._make_request(params)
        if not data or 'vulnerabilities' not in data or len(data['vulnerabilities']) == 0:
            return None

        cve_data = data['vulnerabilities'][0]['cve']
        details = self._parse_single_cve(cve_data)
        self.cache[cache_key] = details
        return details

    def _parse_cve_response(self, data):
        """Parse CVE response from NVD API"""
        cves = []

        if 'vulnerabilities' not in data:
            return cves

        for vuln in data['vulnerabilities']:
            cve_data = vuln['cve']
            cve_info = self._parse_single_cve(cve_data)
            if cve_info:
                cves.append(cve_info)

        return cves

    def _parse_single_cve(self, cve_data):
        """Parse a single CVE entry"""
        try:
            cve_id = cve_data.get('id', '')

            # Get CVSS scores
            cvss_v3 = None
            cvss_v2 = None

            if 'metrics' in cve_data:
                metrics = cve_data['metrics']

                if 'cvssMetricV31' in metrics:
                    cvss_v3 = metrics['cvssMetricV31'][0]['cvssData']
                elif 'cvssMetricV30' in metrics:
                    cvss_v3 = metrics['cvssMetricV30'][0]['cvssData']

                if 'cvssMetricV2' in metrics:
                    cvss_v2 = metrics['cvssMetricV2'][0]['cvssData']

            # Get severity from CVSS
            severity = self._get_severity_from_cvss(cvss_v3, cvss_v2)

            # Get descriptions
            descriptions = cve_data.get('descriptions', [])
            description = ""
            for desc in descriptions:
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break

            # Get references
            references = []
            if 'references' in cve_data:
                for ref in cve_data['references']:
                    references.append({
                        'url': ref.get('url', ''),
                        'source': ref.get('source', '')
                    })

            # Get published/modified dates
            published = cve_data.get('published', '')
            modified = cve_data.get('lastModified', '')

            return {
                'id': cve_id,
                'description': description,
                'severity': severity,
                'cvss_v3': cvss_v3,
                'cvss_v2': cvss_v2,
                'published': published,
                'modified': modified,
                'references': references
            }

        except Exception as e:
            print(f"Error parsing CVE {cve_data.get('id', 'unknown')}: {e}")
            return None

    def _get_severity_from_cvss(self, cvss_v3, cvss_v2):
        """Determine severity from CVSS scores"""
        if cvss_v3:
            base_score = cvss_v3.get('baseScore', 0)
        elif cvss_v2:
            base_score = cvss_v2.get('baseScore', 0)
        else:
            return 'UNKNOWN'

        if base_score >= 9.0:
            return 'CRITICAL'
        elif base_score >= 7.0:
            return 'HIGH'
        elif base_score >= 4.0:
            return 'MEDIUM'
        elif base_score >= 0.1:
            return 'LOW'
        else:
            return 'NONE'

    def extract_software_from_scan_output(self, scan_output):
        """Extract software names and versions from scan output for CVE lookup"""
        software_patterns = [
            r'(\w+)\s+version[:\s]+([\d.]+)',  # "Apache version: 2.4.29"
            r'(\w+)/([\d.]+)',  # "nginx/1.18.0"
            r'Server:\s*([^/\s]+)[/\s]*([\d.]*)',  # "Server: Apache/2.4.29"
            r'Powered by:\s*([^/\s]+)[/\s]*([\d.]*)',  # "Powered by: PHP/7.4.11"
            r'(\w+)\s+([\d.]+)',  # "OpenSSL 1.1.1"
        ]

        found_software = []

        for pattern in software_patterns:
            matches = re.findall(pattern, scan_output, re.IGNORECASE)
            for match in matches:
                name = match[0].strip()
                version = match[1].strip() if len(match) > 1 else ""
                if name and len(name) > 2:  # Avoid false positives
                    found_software.append({
                        'name': name,
                        'version': version
                    })

        # Remove duplicates
        unique_software = []
        seen = set()
        for sw in found_software:
            key = (sw['name'].lower(), sw['version'])
            if key not in seen:
                unique_software.append(sw)
                seen.add(key)

        return unique_software

    def find_relevant_cves(self, scan_output, limit_per_software=5):
        """Find relevant CVEs based on software found in scan output"""
        software_list = self.extract_software_from_scan_output(scan_output)
        all_cves = []

        for software in software_list:
            name = software['name']
            version = software['version']

            # Search by software name
            cves = self.search_cves_by_keyword(name, limit_per_software)

            # Filter by version if available
            if version:
                # Try to find version-specific CVEs
                version_cves = [cve for cve in cves if version in cve.get('description', '')]
                if version_cves:
                    cves = version_cves[:limit_per_software]

            # Add software context to CVEs
            for cve in cves:
                cve['detected_software'] = f"{name} {version}".strip()

            all_cves.extend(cves)

        # Remove duplicates based on CVE ID
        unique_cves = []
        seen_ids = set()
        for cve in all_cves:
            cve_id = cve.get('id')
            if cve_id and cve_id not in seen_ids:
                unique_cves.append(cve)
                seen_ids.add(cve_id)

        # Sort by severity (CRITICAL > HIGH > MEDIUM > LOW > UNKNOWN)
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'UNKNOWN': 4}
        unique_cves.sort(key=lambda x: severity_order.get(x.get('severity', 'UNKNOWN'), 5))

        return unique_cves[:20]  # Return top 20 most relevant CVEs